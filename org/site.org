:PROPERTIES:
:ID:       90a14e14-70e3-42c9-8962-cd7080738871
:ROAM_EXCLUDE: t
:END:
#+hugo_base_dir: ../
#+options: author:nil

* Index
:PROPERTIES:
:EXPORT_FILE_NAME: _index
:EXPORT_HUGO_SECTION: /
:ROAM_EXCLUDE: t
:ID:       c06fb4f3-201b-4b04-94df-4c68c53b955d
:END:

/Please excuse the current aesthetics, I am in the process of making my own [[https://gohugo.io/][Hugo]] theme./

This site is the contains information I wish to share - project writeups, tips on various processes, dotfiles for software configuration, et cetera.

*** I am looking for a job
I am a 2023 Computer Science graduate from Northeastern University who is currently looking for a full-time job in the Boston area - my past internships were in fintech and robotics though I worked on large-scale, web-based systems at both companies. My resume is available [[https://gitlab.com/michzappa/resume/-/raw/master/resume.pdf?inline=false][here]].

I am motivated by understanding how and why complex systems work, especially those that I use - my computing interests reside mostly in operating systems, programming languages, and formal methods. To the same end I also like the more human systems of linguistics, economics, and geopolitics.

My personal projects live on [[https://gitlab.com/users/michzappa][GitLab]] but I also contribute to others' work on [[https://github.com/michzappa][GitHub]].

* Projects :@Projects:
:PROPERTIES:
:EXPORT_HUGO_SECTION: projects
:END:

** Boolean Formulas in Agda :agda:
:PROPERTIES:
:EXPORT_FILE_NAME: boolean_formulas_in_agda
:ID: e2a80cdb-a5c9-4a73-958d-e461bce34cfe
:END:

In Spring 2022 I took "Logic and Computation" with [[https://www.ccs.neu.edu/~pete/][Prof. Pete Manolios]], "an introduction to formal logic and its deep connections to computing" using the [[http://acl2s.ccs.neu.edu/acl2s/doc/][ACL2 Sedan]]. During the course I was one of three students to complete an extra challenge of formalizing Boolean formulas in a programming language of our choice. I chose Agda, as I had been (and still am) slowly working through [[https://plfa.github.io/][Programming Language Foundations in Agda]].

This page is a literate re-creation of [[https://gitlab.com/michzappa/cs2800-challenges][my work]], though syntax highlighting is unfortunately not available at the moment as [[https://github.com/alecthomas/chroma][chroma]] does not support Agda.

#+begin_src agda2
  module cs2800-challenges.BoolFm where

  open import Data.Bool.Base using (Bool; true; false; if_then_else_; _∧_; _∨_) renaming (not to !_; _xor_ to _×_)
  open import Data.Char.Base using (Char)
  open import Data.Char.Properties using (_==_)
  open import Data.List.Base using (List; []; _∷_)
  open import Relation.Binary.PropositionalEquality using (_≡_; refl)
#+end_src

The evaluation of these formulas is performed with an additional environment, where all the variables in the assignment are =true= and all others are =false=.
#+begin_src agda2
assignment = List Char

lookup : Char → assignment → Bool
lookup v [] = false
lookup v (x ∷ xs) with x == v
... | true = true
... | false = lookup v xs
#+end_src

If you give a mouse a boolean formula, he'll want to evaluate it. To reduce duplication, here are some dependently-typed helpers for boolean operators, making the yet-to-be-seen type-specific evaluation functions basically boilerplate.
#+begin_src agda2
boolEval : Bool → Bool
boolEval b = b

varEval : Char → assignment → Bool
varEval v a = lookup v a

notEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → assignment → Bool
notEval f p a = ! (f p a)

orEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → Fm → assignment → Bool
orEval f p q a = (f p a) ∨ (f q a)

andEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → Fm → assignment → Bool
andEval f p q a = (f p a) ∧ (f q a)

impliesEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → Fm → assignment → Bool
impliesEval f p q a = (! (f p a)) ∨ (f q a)

equalEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → Fm → assignment → Bool
equalEval f p q a = if f p a then f q a else ! (f q a)

xorEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → Fm → assignment → Bool
xorEval f p q a = (f p a) × (f q a)

norEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → Fm → assignment → Bool
norEval f p q a = ! ((f p a) ∨ (f q a))

nandEval : ∀ {Fm : Set} → (Fm → assignment → Bool) → Fm → Fm → assignment → Bool
nandEval f p q a = ! ((f p a) ∧ (f q a))
#+end_src

The most permissive boolean formula allows all operators, variables, and literal booleans in all locations.
#+begin_src agda2
  data BoolFm1 : Set where
    bool : Bool → BoolFm1
    var : Char → BoolFm1
    not : BoolFm1 → BoolFm1
    or : BoolFm1 → BoolFm1 → BoolFm1
    and : BoolFm1 → BoolFm1 → BoolFm1
    implies : BoolFm1 → BoolFm1 → BoolFm1
    equal : BoolFm1 → BoolFm1 → BoolFm1
    xor : BoolFm1 → BoolFm1 → BoolFm1
    nor : BoolFm1 → BoolFm1 → BoolFm1
    nand : BoolFm1 -> BoolFm1 -> BoolFm1

  B1Eval : BoolFm1 → assignment → Bool
  B1Eval (bool b) a = boolEval b
  B1Eval (var v) a = varEval v a
  B1Eval (not p) a = notEval B1Eval p a
  B1Eval (or p q) a = orEval B1Eval p q a
  B1Eval (and p q) a = andEval B1Eval p q a
  B1Eval (implies p q) a = impliesEval B1Eval p q a
  B1Eval (equal p q) a = equalEval B1Eval p q a
  B1Eval (xor p q) a = xorEval B1Eval p q a
  B1Eval (nor p q) a = norEval B1Eval p q a
  B1Eval (nand p q) a = nandEval B1Eval p q a
#+end_src

But since all logical operators can be [[https://en.wikipedia.org/wiki/Logical_NOR#Other_Boolean_Operations_in_terms_of_the_Logical_NOR][defined in terms of nor]], why include all of them? (variables and literal booleans are still useful though).
#+begin_src agda2
  data NorFm : Set where
    bool : Bool → NorFm
    var : Char → NorFm
    nor : NorFm → NorFm → NorFm

  NorEval : NorFm → assignment → Bool
  NorEval (bool b) a = boolEval b
  NorEval (var v) a = varEval v a
  NorEval (nor p q) a = norEval NorEval p q a
#+end_src

But we don't need literal boolean /everywhere/ - the only formulas in =NorCPFm= which contain =true= or =false= are =true= and =false= themselves. =NorNCFm= is used to help structure this definition, it is not by itself a proper boolean formula.
#+begin_src agda2
  data NorNCFm : Set where
    var : Char → NorNCFm
    nor : NorNCFm → NorNCFm → NorNCFm

  data NorCPFm : Set where
    bool : Bool → NorCPFm
    NorNCCFm→NorCPFm : NorNCFm → NorCPFm

  ConstPropNorFm : NorFm → NorCPFm
  ConstPropNorFm (bool b) = bool b
  ConstPropNorFm (var v) = NorNCCFm→NorCPFm (var v)
  ConstPropNorFm (nor p q) with (ConstPropNorFm p) | (ConstPropNorFm q)
  ... | bool true | _ = bool false
  ... | _ | (bool true) = bool false
  ... | bool false | bool false = bool true
  ... | bool false | NorNCCFm→NorCPFm nq = NorNCCFm→NorCPFm (nor nq nq)
  ... | NorNCCFm→NorCPFm np | bool false = NorNCCFm→NorCPFm (nor np np)
  ... | NorNCCFm→NorCPFm np | NorNCCFm→NorCPFm nq = NorNCCFm→NorCPFm (nor np nq)

  NorNCEval : NorNCFm → assignment → Bool
  NorNCEval (var v) a = varEval v a
  NorNCEval (nor p q) a = norEval NorNCEval p q a

  NorCPEval : NorCPFm → assignment → Bool
  NorCPEval (bool b) a = boolEval b
  NorCPEval (NorNCCFm→NorCPFm p) a = NorNCEval p a
#+end_src

Finally, the most permissive type - which must be defined last to allow for a subtype-like relationship with the previously defined constructors. Agda does not easy mimic the "observation-based" type system of ACL2s, this is the best I came up with at the time.
#+begin_src agda2
  data BoolFm : Set where
    bool : Bool → BoolFm
    var : Char → BoolFm
    not : BoolFm → BoolFm
    or : BoolFm → BoolFm → BoolFm
    and : BoolFm → BoolFm → BoolFm
    implies : BoolFm → BoolFm → BoolFm
    equal : BoolFm → BoolFm → BoolFm
    xor : BoolFm → BoolFm → BoolFm
    nor : BoolFm → BoolFm → BoolFm
    nand : BoolFm → BoolFm → BoolFm
    BoolFm1→BoolFm : BoolFm1 → BoolFm
    NorFm→BoolFm : NorFm → BoolFm
    NorNCFm→BoolFm : NorNCFm → BoolFm
    NorCPFm→BoolFm : NorCPFm → BoolFm

  BfEval : BoolFm → assignment → Bool
  BfEval (bool b) a = boolEval b
  BfEval (var v) a = varEval v a
  BfEval (not p) a = notEval BfEval p a
  BfEval (or p q) a = orEval BfEval p q a
  BfEval (and p q) a = andEval BfEval p q a
  BfEval (implies p q) a = impliesEval BfEval p q a
  BfEval (equal p q) a = equalEval BfEval p q a
  BfEval (xor p q) a = xorEval BfEval p q a
  BfEval (nor p q) a = norEval BfEval p q a
  BfEval (nand p q) a = nandEval BfEval p q a
  BfEval (BoolFm1→BoolFm p) a = B1Eval p a
  BfEval (NorFm→BoolFm p) a = NorEval p a
  BfEval (NorNCFm→BoolFm p) a = NorNCEval p a
  BfEval (NorCPFm→BoolFm p) a = NorCPEval p a
#+end_src

Using Agda to mimic a more "normal" language like the Common Lisp-derived ACL2s was an interesting exercise. It is definitely not as flexible and suffers for that with problems and data like these, especially when combined with my lack of familiarity. With my current level of knowledge I would not want to approach novel, complex problems with Agda but I think it is fun to formalize the behavior of existing programs or systems.

** Klox :nix:pl:
:PROPERTIES:
:EXPORT_FILE_NAME: klox
:ID: 32812ccf-5c8e-4022-ab91-1db4c2ce4abb
:END:

[[https://gitlab.com/michzappa/klox][Klox]] is my implementation of [[*Lox][Lox]] in Kotlin. It was a straightforward port from the book's [[https://craftinginterpreters.com/a-tree-walk-interpreter.html][first interpreter]], largely due to Kotlin's similarity to Java.

In addition to completing a number of the book's challenges (notably anonymous functions), I also extended the language by [[https://gitlab.com/michzappa/klox/-/commit/881cad085efa7d37689c039ef206cfa0d18fc110][adding a data structure]] which has the interface of a LISP-style linked list.
#+begin_src lox
var l = [1, 2, 3];
#+end_src

=cons=, =empty=, =first= and =rest= are native functions implemented in Kotlin - all other functionality is definable in Klox itself. Examples from the [[https://gitlab.com/michzappa/klox/-/blob/master/app/src/main/resources/stdlib.lox][standard library]]:
#+begin_src lox
  // f takes one argument
  fun map(f, l) {
    if (empty(l)) {
      return l;
    } else {
      return cons(f(first(l)), map(f, rest(l)));
    }
  }

  // f takes two arguments (list element, accumulated value)
  fun foldr(f, acc, l) {
    if (empty(l)) {
      return acc;
    } else {
      return f(first(l), foldr(f, acc, rest(l)));
    }
  }

  // f takes two arguments (list element, accumulated value)
  fun foldl(f, acc, l) {
    if (empty(l)) {
      return acc;
    } else {
      return foldl(f, f(first(l), acc), rest(l));
    }
  }

  fun get_nth(l, n) {
    if (empty(l)) {
      return nil;
    } else {
      // klox is 1-indexed
      if (n == 1) {
        return first(l);
      } else {
        return get_nth(rest(l), n - 1);
      }
    }
  }

  fun set_nth(l, n, x) {
    if (empty(l)) {
      if (n == 1) {
        return [x];
      } else {
        // klox allows sparse lists
        return cons(nil, set_nth([], n - 1, x));
      }
    } else {
      if (n == 1) {
        return cons(x, rest(l));
      } else {
        return cons(first(l), set_nth(rest(l), n - 1, x));
      }
    }
  }
#+end_src

*** Building with Nix
The most straightforward way to build a Kotlin project with Nix is [[https://github.com/tadfisher/gradle2nix][=gradle2nix=]], though it has been unmaintained since <2021-03-10 Wed>. I use [[https://github.com/randomnetcat/gradle2nix][this fork]], which includes patches for use with current Nix and updated package repositories, and made [[https://gitlab.com/michzappa/nix-kt-template ][this template]] as a starting point for developing a Kotlin project with Nix.

The Klox interpreter can be run via Nix with =nix run gitlab:michzappa/klox=.

*** GraalVM
In addition to building the standard JVM artifacts, I [[https://gitlab.com/michzappa/klox/-/commit/40f768522d25313715ebb8599971d139ede84b20][added]] an option to use [[https://www.graalvm.org/][GraalVM]] and generate a native executable of the interpreter.

The general GraalVM + [[https://gradle.org/][Gradle]] instructions can be followed, but a couple Nix-specific configurations were needed.
- Set =GRAALVM_HOME= in the =devShell=
  #+begin_src diff
    modified   flake.nix
       with inputs;
       flake-utils.lib.eachDefaultSystem (system:
         let
           pkgs = (import nixpkgs { inherit system; });
           buildGradle = pkgs.callPackage ./gradle-env.nix { };
    +      graalvm = pkgs.graalvm17-ce;
         in {
           devShell = pkgs.mkShell {
             buildInputs = with pkgs; [
    +          graalvm
               gradle
               inputs.gradle2nix.packages.${system}.default
               kotlin
               kotlin-language-server
               ktlint
             ];
    +        shellHook = ''
    +          export GRAALVM_HOME=${graalvm};
    +        '';
           };

  #+end_src

- Tell Gradle to blindly use =GRAALVM_HOME=, don't try to detect the location
  #+begin_src diff
    modified   app/build.gradle.kts
    +  graalvmNative {
    +      binaries {
    +          named("main") {
    +              // Disable native toolchain checking
    +              buildArgs.add("-H:-CheckToolchain")
    +              // Set executable name
    +              imageName.set("klox")
    +          }
    +      }
    +      // Just use GRAALVM_HOME for finding the GraalVM installation
    +      toolchainDetection.set(false)
    +  }

  #+end_src

- Create additional flake output
  #+begin_src diff
    modified   flake.nix
    +  native = buildGradle {
    +    configurePhase = ''
    +      export GRAALVM_HOME=${graalvm};
    +    '';
    +    envSpec = ./gradle-env.json;
    +    gradleFlags = [ "nativeCompile" ];
    +    installPhase = ''
    +      mkdir -p $out/bin
    +      cp app/build/native/nativeCompile/klox $out/bin
    +    '';
    +    nativeBuildInputs = [ graalvm ];
    +    pname = "klox";
    +    src = ./.;
    +    version = "native";
    +  };

  #+end_src
The native executable is anecdotally faster than the JVM artifacts, even with the startup overhead of the JVM taken into account. The speedup was particularly noticable on highly recursive programs like a naïve Fibonacci implementation.

The Klox interpreter native executable can be run via Nix with =nix run gitlab:michzappa/klox#native=.

*** Scheme Backend
I also tried to make an additional back-end for Klox which [[https://gitlab.com/michzappa/klox/-/tree/compiler][compiled it to Scheme]]. It was a fun exercise, though I ultimately gave up on trying to smush the side-effects and statements of Klox into the purity and expressions of Scheme. Perhaps [[https://common-lisp.net/][Common Lisp]] would have been a better target...

*** Lox
The [[https://craftinginterpreters.com/the-lox-language.html][Lox programming language]] is the language described and implemented by the venerable [[https://craftinginterpreters.com/][Crafting Interpreters]] book. The language's syntax and semantics are C/JavaScript-like - it is object-oriented and dynamically typed.

**** Variable Assignment
#+begin_src lox
  var imAVariable = "here is my value";
  imAVariable = "now it's this!";

  var meToo;
  meToo = "my first value!";
#+end_src

**** Loops
#+begin_src lox
  var a = 1;
  while (a < 10) {
    print a;
    a = a + 1;
  }

  for (var a = 1; a < 10; a = a + 1) {
    print a;
  }
#+end_src

**** Functions
=print= is a built-in statement.
#+begin_src lox
  fun sum(a, b) {
    print a + b;
  }
#+end_src

**** Classes
#+begin_src lox
  class Breakfast {
    cook() {
      print "Eggs a-fryin'!";
    }

    serve(who) {
      print "Enjoy your breakfast, " + who + ".";
    }
  }

  var breakfast = Breakfast();
  breakfast.cook();
  breakfast.serve("me");
#+end_src

**** Inheritance
#+begin_src lox
  class Brunch < Breakfast {
    init(meat, bread, drink) {
      super.init(meat, bread);
      this.drink = drink;
    }

    server(who) {
      print "Enjoy your brunch, " + who + ".";
    }
  }
#+end_src

* Tips :@Tips:
:PROPERTIES:
:EXPORT_HUGO_SECTION: tips
:END:

** Flashing CalyxOS From NixOS :android:nix:
:PROPERTIES:
:EXPORT_FILE_NAME: flashing_calyxos_from_nixos
:ID:       6bc49858-c3aa-45dd-84ce-e9715cae57c7
:END:

/I am now using GrapheneOS and will not be updating this instructions./

The requirements for flashing CalyxOS on a Linux computer, at the time of writing (<2022-07-31 Sun>), are:
- have Android's =platform-tools= installed
- a user in the group =adbusers=
- appropriate =udev= rules

These are all easily achievable on [[https://nixos.org/][NixOS]] with the following options:
#+begin_src nix
  {
    programs.adb.enable = true;
    services.udev.packages = [ pkgs.android-udev-rules ];
    users.users.<name>.extraGroups = "adbusers";
  }
#+end_src

However the default [[https://calyxos.org/install/devices/blueline/linux/][CalyxOS installation instructions]] (for my Pixel 3) do not work. This is because the flashing process pulls down pre-compiled =platform-tools= binaries into the working directory and is hard-coded to use them (pre-compiled binaries for Linux always assume [[https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.html][FHS]], and NixOS does not comply).

An FHS environment /can/ be created by [[https://nixos.org/manual/nixpkgs/stable/#sec-fhs-environments][=BuildFHSEnv=]], but the user in that environment is anonymous and won't be part of the =adbusers= group.

Thus, in any scenario where the user has the right permissions the local =platform-tools= binaries won't run, and in any scenario where the local =platform-tools= will run the user doesn't have the right permissions.

Happily, =device-flasher= is [[https://gitlab.com/CalyxOS/device-flasher][open-source]]! The hard-coded local path can be found and removed, forcing it to use the globally-available =platform-tools= (which were compiled and installed appropriately for NixOS).
#+begin_src diff
        fmt.Println(platformToolsZip + " checksum verification failed")
        return err
    }
-	platformToolsPath := cwd + string(os.PathSeparator) + "platform-tools" + string(os.PathSeparator)
+	platformToolsPath := ""
    pathEnvironmentVariable := func() string {
        if OS == "windows" {
            return "Path"
#+end_src

I [[https://gitlab.com/michzappa/device-flasher][forked]] the repo and added this change (among other miscellany and a =flake.nix=). Now NixOS users can follow the CalyxOS instructions verbatim, other than substituting the default =device-flasher.linux= with the binary produced by =nix build gitlab:michzappa/device-flasher=!

** Opening A File In Emacs From Intellij :emacs:
:PROPERTIES:
:EXPORT_FILE_NAME: opening_a_file_in_emacs_from_intellij
:ID:       d5674eb7-cbc7-4d5c-9dd9-5d50b07fd089
:END:

Based on [[https://blog.developer.atlassian.com/emacs-intellij/][Quick Tip: Getting Emacs and IntelliJ to play together]]. There must already be an Emacs running in server mode (=--daemon=).

1. Make this script, which opens the file in Emacs with the cursor in the same location as in Intellij.
   #+begin_src shell
     #! /usr/bin/env sh

     file=$1
     line=$2
     column=$3

     emacsclient -n -e "
       (prognc
         (find-file \"$file\")
         (goto-char (point-min))
         (forward-line (1- $line))
         (forward-char (1- $column))
         (recenter-top-bottom)
         (select-frame-set-input-focus (selected-frame)))
     "
   #+end_src

2. Make an External Tool in Intellij for this script.
   - Arguments: =$FilePath$ $LineNumber$ $ColumnNumber$=
   - Working directory: =$FileDir$=

3. Add a keybinding for this External Tool in Intellij. I use the Emacs keymap and add this at Meta+O.
